!-------------------------------------------!
! File for position dependent work function !
! Kristinn Torfason                         !
! 19.10.18                                  !
!-------------------------------------------!

  double precision pure function w_theta_xy(pos)
    double precision, dimension(1:3), intent(in) :: pos

   
    !w_theta_xy = w_theta_triangle(pos)
    w_theta_xy = w_theta_checkerboard(pos)
    !w_theta_xy = w_theta_checkerboard_2x2(pos)
    !w_theta_xy = w_theta_constant()
    !w_theta_xy = w_theta_gaussian(pos)

  end function w_theta_xy

  ! ----------------------------------------------------------------------------
  ! Constant work function
  !
  double precision pure function w_theta_constant()
    w_theta_constant = 2.0d0
  end function w_theta_constant

  ! ----------------------------------------------------------------------------
  ! A Gaussian work function that dips
  !
  double precision pure function w_theta_gaussian(pos)
    double precision, intent(in), dimension(1:3) :: pos
    double precision, parameter                  :: A = -0.20d0, B = 25.0d0*length_scale
    double precision, parameter                  :: x_c = 50.0d0*length_scale, y_c = 50.0d0*length_scale
    double precision                             :: x, y

    x = pos(1)
    y = pos(2)

    w_theta_gaussian = 4.70d0 + A*exp( -1.0d0*( (x-x_c)**2/(2*B**2) + (y-y_c)**2/(2*B**2) ) )
  end function w_theta_gaussian

  ! ----------------------------------------------------------------------------
  ! Triangle work function that splits the emitter in two
  ! |----|
  ! |4.7/|
  ! |  / |
  ! | /  |
  ! |/4.5|
  ! |----|
  !
  double precision pure function w_theta_triangle(pos)
    double precision, intent(in), dimension(1:3) :: pos
    double precision                             :: x, y

    x = pos(1)
    y = pos(2)

    if (x > y) then
      w_theta_triangle = 4.7d0 !+ A*exp( -1.0d0*( (x-x_c)**2 + (y-y_c)**2 )/(2.0d0*B**2) )
    else
      w_theta_triangle = 4.5d0
    end if
  end function w_theta_triangle

  ! ----------------------------------------------------------------------------
  ! Checkerboard work function
  ! Takes an array and maps it to the emitter area
  ! An array like this
  ! |----|----|----|
  ! | 1  | 2  | 3  |
  ! |----|----|----|
  ! | 4  | 5  | 6  |
  ! |----|----|----|
  ! would map exactly like this to the emitter area
  !
  double precision pure function w_theta_checkerboard(pos)
    double precision, intent(in), dimension(1:3)  :: pos
    double precision,             dimension(1:3)  :: pos_scaled
    double precision                              :: x, y
    double precision                              :: x_len, y_len
    integer                                       :: x_i, y_i
    integer, parameter                            :: emit = 1 ! Assume emitter nr. 1 for now
    integer, parameter                            :: y_num = 4, x_num = 4
    double precision, dimension(1:y_num, 1:x_num) :: w_theta_arr

    ! To do: Read this from a file
    !w_theta_arr(1, 1:4) = (/ 4.70d0, 4.70d0, 4.70d0, 4.70d0 /)
    !w_theta_arr(2, 1:4) = (/ 4.70d0, 4.65d0, 4.65d0, 4.70d0 /)
    !w_theta_arr(3, 1:4) = (/ 4.70d0, 4.65d0, 4.65d0, 4.70d0 /)
    !w_theta_arr(4, 1:4) = (/ 4.70d0, 4.70d0, 4.70d0, 4.70d0 /)

    w_theta_arr(1, 1:4) = (/ 4.65d0, 4.65d0, 4.65d0, 4.50d0 /)
    w_theta_arr(2, 1:4) = (/ 4.65d0, 4.70d0, 4.70d0, 4.65d0 /)
    w_theta_arr(3, 1:4) = (/ 4.65d0, 4.70d0, 4.70d0, 4.65d0 /)
    w_theta_arr(4, 1:4) = (/ 4.65d0, 4.65d0, 4.65d0, 4.65d0 /)

    ! Scale x, y to unit square
    pos_scaled(:) = (pos(:) - emitters_pos(1:3, emit)) / emitters_dim(:, emit)
    x = pos_scaled(1)
    y = pos_scaled(2)

    ! Length of each section
    x_len = 1.0/x_num
    y_len = 1.0/y_num

    ! Calculate the position in the matrix
    x_i = floor(x/x_len) + 1
    y_i = floor(y/y_len) + 1

    ! Check the numbers
    if (x_i > x_num) then
      x_i = x_num
    else if (x_i < 1) then
      x_i = 1
    end if
    if (y_i > y_num) then
      y_i = y_num
    else if (y_i < 1) then
      y_i = 1
    end if
    ! Reverse the y-direction in the array
    y_i = y_num - y_i + 1

    ! Return the results
    w_theta_checkerboard = w_theta_arr(y_i, x_i)

  end function w_theta_checkerboard

  double precision pure function w_theta_checkerboard_2x2(pos)
    double precision, intent(in), dimension(1:3) :: pos
    double precision,             dimension(1:3) :: pos_scaled
    double precision                             :: x, y
    integer, parameter                           :: emit = 1

    ! Scale x, y to unit square
    pos_scaled(:) = (pos(:) - emitters_pos(1:3, emit)) / emitters_dim(:, emit)
    x = pos_scaled(1)
    y = pos_scaled(2)

    !
    ! |---|---|
    ! | 1 | 2 |
    ! |---|---|
    ! | 3 | 4 |
    ! |---|---|
    !
    ! Use unit square coordinates
    if (x > 0.5d0) then
      if (y > 0.5d0) then
        ! 2
        w_theta_checkerboard_2x2 = 4.75d0
      else
        ! 4
        w_theta_checkerboard_2x2 = 4.68d0
      end if
    else
      if (y > 0.5d0) then
        ! 1
        w_theta_checkerboard_2x2 = 4.65d0
      else
        ! 3
        w_theta_checkerboard_2x2 = 4.72d0
      end if
    end if
  end function w_theta_checkerboard_2x2